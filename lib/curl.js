// Generated by CoffeeScript 1.1.4-3
(function() {
  var Curl, curl, curl_id,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  try {
    Curl = require(__dirname + '/../build/Release/node-curl').Curl;
  } catch (e) {
    Curl = require(__dirname + '/../build/default/node-curl').Curl;
  }

  Curl.prototype.setopt = function(ooption, value) {
    var option, option_id;
    option = ooption.toUpperCase();
    if ((option_id = Curl.integer_options[option]) != null) {
      return this.setopt_int_(option_id, value >> 0);
    } else if ((option_id = Curl.string_options[option]) != null) {
      return this.setopt_str_(option_id, value.toString());
    } else {
      throw new Error("unsupported option " + option);
    }
  };

  Curl.prototype.getinfo = function(oinfo) {
    var info, info_id;
    info = oinfo.toUpperCase();
    if ((info_id = Curl.integer_infos[info]) != null) {
      return this.getinfo_int_(info_id);
    } else if ((info_id = Curl.string_infos[info]) != null) {
      return this.getinfo_str_(info_id);
    } else if ((info_id = Curl.double_infos[info]) != null) {
      return this.getinfo_double_(info_id);
    } else {
      throw new Error("unsupproted info " + oinfo);
    }
  };

  Curl.prototype.perform = function() {
    this.perform_();
    return Curl.process();
  };

  Curl.process = function() {
    var once;
    if (Curl.in_process) return;
    return (once = function() {
      var num;
      num = Curl.process_();
      if (num > 0) {
        Curl.in_process = true;
        return setTimeout(once, 80);
      } else {
        return Curl.in_process = false;
      }
    })();
  };

  curl_id = 0;

  curl = function() {
    var args, c, cb, chunks, k, length, options, res, url, v;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    cb = args.pop();
    url = args[0], options = args[1];
    if (options == null) options = {};
    c = new Curl();
    c.id = ++curl_id;
    c.setopt('FOLLOWLOCATION', 1);
    c.setopt('ACCEPT_ENCODING', 'gzip');
    chunks = [];
    length = 0;
    res = {};
    for (k in options) {
      if (!__hasProp.call(options, k)) continue;
      v = options[k];
      c.setopt(k, v);
    }
    c.on_write = function(chunk) {
      chunks.push(chunk);
      length += chunk.length;
      return console.info("on_write " + c.id + " " + chunk.length);
    };
    c.on_end = function() {
      var chunk, data, i, position, st, _i, _len;
      data = new Buffer(length);
      position = 0;
      for (_i = 0, _len = chunks.length; _i < _len; _i++) {
        chunk = chunks[_i];
        chunk.copy(data, position);
        position += chunk.length;
      }
      st = Date.now();
      i = 0;
      while (Date.now() - st < 500) {
        ++i;
      }
      res.body = data;
      res.status = res.code = c.getinfo('RESPONSE_CODE');
      res.info = function(info) {
        return c.getinfo(info);
      };
      console.info("id: " + c.id);
      return cb(null, res);
    };
    c.on_error = function(err) {
      var _this = this;
      return process.nextTick(function() {
        return cb(err, null);
      });
    };
    c.setopt('URL', url);
    return c.perform();
  };

  curl.Curl = Curl;

  module.exports = curl;

}).call(this);
